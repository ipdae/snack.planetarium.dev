<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><title>플라네타리움 엔지니어링 스낵</title><link rel="self" href="https://snack.planetarium.dev/kor/index.xml"/><link rel="alternate" href="https://snack.planetarium.dev/kor/" title="플라네타리움 엔지니어링 스낵"/><link rel="alternate" href="https://snack.planetarium.dev/eng/" hreflang="en" title="Planetarium Engineering Snack"/><updated>2019-06-18T00:00:00&#43;00:00</updated><id>https://snack.planetarium.dev/kor/</id><entry><title>예제로 보는 TURN</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/06/nat_traversal_2/" title="예제로 보는 TURN"/><id>https://snack.planetarium.dev/kor/2019/06/nat_traversal_2/</id><published>2019-06-18T00:00:00&#43;00:00</published><updated>2019-06-18T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;안녕하세요. 플라네타리움 개발팀 문성원입니다. 지난 시간에 &lt;a href=&#34;https://en.wikipedia.org/wiki/NAT_traversal&#34;&gt;NAT 통과 기법&lt;/a&gt;에 대해서 &lt;a href=&#34;https://snack.planetarium.dev/kor/2019/04/nat_traversal_1/&#34;&gt;소개해 드렸었는데요&lt;/a&gt;. 오늘은 그중에서 &lt;a href=&#34;https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT&#34;&gt;TURN&lt;/a&gt;을 살펴볼까 합니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Traversal Using Relays around NAT&amp;rdquo;라는 이름에서 알 수 있듯이 TURN은 공인 IP를 가진 서버가 통신을 원하는 단말들을 중계하는 방식을 일컫습니다. 단순히 기능이나 순서를 나열하는 것으론 이해가 어려울 수 있으니, 저희가 만들고 있는 &lt;a href=&#34;https://libplanet.io/&#34;&gt;Libplanet&lt;/a&gt;이 실제로 TURN을 사용하는 방식을 예로 설명하도록 하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;블록-체인과-nat&#34;&gt;블록 체인과 NAT&lt;/h2&gt;
&lt;p&gt;Libplanet은 블록체인 기술을 게임 개발에 쉽게 사용할 수 있게끔 하는 라이브러리입니다. 많은 블록체인 구현체들은 분산된 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%85%B8%EB%93%9C_(%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)&#34;&gt;노드(node)&lt;/a&gt;간의 통신에 &lt;a href=&#34;https://ko.wikipedia.org/wiki/P2P&#34;&gt;P2P&lt;/a&gt; 형태의 네트워크를 사용하며, 이는 저희 Libplanet도 마찬가지입니다. 다만 다른 블록체인 구현체들과는 다르게, Libplanet을 통해 블록체인이 구현되는 애플리케이션은 게임입니다. 일반적으로 이러한 게임은 개인용 컴퓨터나 거치형 콘솔, 그리고 스마트폰과 같은 개인용 장비에서 실행되는데, 이런 장비의 대부분은 NAT로 구성된 네트워크 위에서 별도의 공인 IP를 가지지 않습니다. 즉 이러한 장비에서 실행되는 애플리케이션이 P2P 통신을 하려면 NAT를 통과하지 않을 수 없습니다.&lt;/p&gt;
&lt;p&gt;이때문에 Libplanet은 0.2.0부터 TURN을 이용한 릴레이를 지원합니다. 바로 다음과 같은 과정을 통해서요.&lt;/p&gt;
&lt;h2 id=&#34;포트-할당&#34;&gt;포트 할당&lt;/h2&gt;
&lt;p&gt;TURN을 통한 릴레이의 첫 단계는 포트 할당이라고 알려진 단계입니다. NAT 바깥에서 중계를 원하는 노드는 (필요하다면 적절한 인증 정보와 함께) 포트 할당 요청(allocation request)을 TURN 서버로 보냅니다. 적당히 간추리면 대충 이런 내용이겠죠.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;노드: 공인 IP와 포트를 통해 중계를 받고 싶습니다. 적당한 IP와 포트를 할당해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TURN 서버는 요청이 올바르다면 설정에 따라 적당한 IP와 포트를 골라서 연결을 받을 수 있게 열어 두고 아래와 같은 응답을 보낼 것입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TURN 서버: 포트를 할당하였습니다. 앞으로 중계할 할 주소는 &lt;code&gt;54.12.1.3:65002&lt;/code&gt;입니다. (논스: &lt;code&gt;xyz&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이렇게 포트 할당을 요청한 연결은 &lt;em&gt;제어 연결&lt;/em&gt;(control connection)로 불리며, 이후 TURN 서버와 노드의 통신에 사용됩니다. 여기서 한 가지 주의할 점이 TURN 서버가 응답에 포함하는 논스(nonce)인데요. 이 논스는 제어 연결마다 고유하며, 획득한 논스를 이 제어 연결의 모든 요청에 같이 보내줘야 합니다. (혹은 논스 불일치(stale nonce) 에러를 받고 다시 요청하는 방법도 있습니다.)&lt;/p&gt;
&lt;h2 id=&#34;권한-요청-및-승인&#34;&gt;권한 요청 및 승인&lt;/h2&gt;
&lt;p&gt;이렇게 할당 받은 IP와 포트(&lt;code&gt;54.12.1.3:65002&lt;/code&gt;)로 다른 노드가 바로 접속할 수 있으면 좋겠지만 아직 한 단계가 더 필요합니다. 바로 권한 요청인데요. 이는 포트를 할당받은 노드가 할당 받은 포트를 어떤 IP의 노드에게 접속 가능하게끔 TURN 서버에 요청하는 것입니다. 권한 요청이 되지 않은 연결은 모두 차단되는데, 이는 중계를 원하는 노드가 접속을 원하는 노드의 IP 정보를 사전에 알고 있어야 함을 뜻합니다.&lt;/p&gt;
&lt;p&gt;하지만 실생활에서 많은 사용자는 자신의 공인 IP를 알고 있지 않거나 신경쓰지 않기 때문에, 이러한 정보를 직접 전달해야한다는 건 무척이나 어려운 일입니다. 이를 해결하기 위해서 &lt;a href=&#34;https://webrtc.org/&#34;&gt;WebRTC&lt;/a&gt; 같은 사용 예에서는 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling&#34;&gt;시그널링(signalling)&lt;/a&gt; 단계에서 접속할 노드의 IP 정보를 미리 알아내곤 합니다. 한편 Libplanet에서는 STUN 프로토콜을 통해 NAT 뒤에 있는 지를 확인하고, 만약 그렇다면 STUN을 통해 확인된 IP를 공인 IP로 릴레이 된 IP/포트와 함께 다른 노드에 전파합니다. 이러한 정보를 받은 노드는, 릴레이 된 정보로 접속하기에 앞서서 먼저 공인 IP를 통해 권한 요청을 하는 절차를 거칩니다.&lt;/p&gt;
&lt;p&gt;이렇게 노드가 접속을 원하는 다른 노드의 공인 IP(&lt;code&gt;10.1.1.1&lt;/code&gt;)을 알고 있다면, 권한 요청은 아마 아래와 같을 것입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;노드: &lt;code&gt;10.1.1.1&lt;/code&gt;에서 &lt;code&gt;54.12.1.3:65002&lt;/code&gt;로 오는 요청을 허가해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 접근 권한은 300초의 유효기간(lifetime)이 지나면 만료되는데, 이를 방지하기 위해서는 권한을 요청했던 노드가 다시 TURN 서버에게 권한 요청을 해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;연결-알림-및-새-연결-요청하기&#34;&gt;연결 알림 및 새 연결 요청하기&lt;/h2&gt;
&lt;p&gt;이렇게 권한 요청 및 승인까지 끝마치고 나면, 드디어 할당 받은 IP와 포트로 승인된 다른 노드가 접속할 수 있습니다. 다른 노드가 할당된 IP와 포트를 통해 접속하면 TURN 서버는 이를 감지하여 다음과 같은 메시지를 제어 연결로 보냅니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TURN 서버: &lt;code&gt;10.1.1.1&lt;/code&gt;에서 &lt;code&gt;54.12.1.3:65002&lt;/code&gt;로 연결 시도가 있었습니다. (연결 ID: &lt;code&gt;1234&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TURN 서버에 중계를 요청한 노드가 이 연결을 수락하려면, 제어 연결이 아닌 새로운 연결을 만들어서 TURN 서버에 요청하면 됩니다. 이 때 요청 받은 외부 연결을 구분하기 위해서 연결 알림 메시지의 연결 ID(connection ID)를 보내야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;노드: 연결 &lt;code&gt;1234&lt;/code&gt;에 대한 데이터는 앞으로 이 연결로 전달해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이렇게 새롭게 생긴 연결을 &lt;em&gt;데이터 연결(data connection)&lt;/em&gt;이라고 합니다. 이후 &lt;code&gt;54.12.1.3:65002&lt;/code&gt;로 보내는 요청은 이 데이터 연결을 통해 전달되며, 해당 IP/포트에 연결된 노드에 응답하고 싶을때도 이 데이터 연결에 전송하면 TURN 서버를 거쳐서 노드에 전달됩니다.&lt;/p&gt;
&lt;h2 id=&#34;남은-일들&#34;&gt;남은 일들&lt;/h2&gt;
&lt;p&gt;실제로 응답을 제대로 보내기 위해서는, 앞서 만든 데이터 연결과 Libplanet 노드의 요청-응답용 연결을 다시 중계 할 필요가 있습니다. 이 부분은 노드 안에서만 잘 처리되면 되기 때문에 별도의 프로토콜이나 공개 표준은 정해지지 않았습니다. 만약 TURN 클라이언트가 웹 서버와 별도의 프로세스로 실행된다면 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0&#34;&gt;IPC&lt;/a&gt;, 같은 프로세스라면 스레드 간 통신 등을 이용해 이를 적절히 처리해주시면 됩니다. Libplanet에서는 별도 TCP 프록시를 로컬에서 실행하여 이를 릴레이합니다.&lt;/p&gt;</content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.3 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/05/libplanet-0.3/" title="Libplanet 0.3 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/05/libplanet-0.3/" hreflang="en" title="Libplanet 0.3 Released"/><id>https://snack.planetarium.dev/kor/2019/05/libplanet-0.3/</id><published>2019-05-31T00:00:00&#43;00:00</published><updated>2019-05-31T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;안녕하세요. 저희 팀은 &lt;a href=&#34;https://libplanet.io/&#34;&gt;Libplanet&lt;/a&gt;의 세번째 마이너 버전인 &lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.3.0&#34;&gt;0.3 버전&lt;/a&gt;을 릴리스했습니다.&lt;/p&gt;
&lt;p&gt;Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 0.3 버전의 주요 변경 사항에 대해 다루겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;버전이-다른-노드를-만났을-때-반응하는-api&#34;&gt;버전이 다른 노드를 만났을 때 반응하는 API&lt;/h2&gt;
&lt;p&gt;0.2 버전부터 &lt;code&gt;Swarm&lt;/code&gt; 생성자에 &lt;code&gt;appProtocolVersion&lt;/code&gt;이 추가되어 노드의 프로토콜 버전을 지정하도록 했습니다.
이번 0.3 버전에서는 &lt;code&gt;Swarm.DifferentVersionPeerEncountered&lt;/code&gt; 이벤트 핸들러를 통해 버전이 다른
노드를 만났을 때의 행동을 지정해 줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 자신보다 높은 프로토콜 버전의 메시지를 받을 경우 게임 앱을 업그레이드하도록 하는 핸들러 등을
&lt;code&gt;Swarm.DifferentVersionPeerEncountered&lt;/code&gt;로 넘겨줄 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;액션-렌더링-api&#34;&gt;액션 렌더링 API&lt;/h2&gt;
&lt;p&gt;기존에는 게임에서 액션이 실제로 처리되었는지, 즉 액션의 실행 결과가 &lt;code&gt;GetStates()&lt;/code&gt; 메소드의 결과에 언제 반영되는지 신호(이벤트)를 받을 수 없었습니다.
따라서 특정 주소의 액션이 처리되었다는 것을 확인하기 위해서는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/폴링_(컴퓨터_과학)&#34;&gt;폴링&lt;/a&gt; 등의 방법을 이용해 해당 주소의 상태가 액션 이후의 상태로 변경되었는지 확인해야 했습니다.
이런 방식은 구현이 복잡하고 번거로울 뿐 아니라 액션의 처리가 확인될 때까지 주소의 상태를 수차례 가져와야 하므로 성능적인 측면에서도 문제가 있습니다.&lt;/p&gt;
&lt;p&gt;이런 문제를 해결하기 위해 이번 버전에서는 액션 렌더링 API가 추가되었습니다.
&lt;a href=&#34;https://docs.libplanet.io/0.3.0/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Render_Libplanet_Action_IActionContext_Libplanet_Action_IAccountStateDelta_&#34;&gt;&lt;code&gt;IAction.Render()&lt;/code&gt;&lt;/a&gt; 메서드 구현을 통해 게임에서는 액션의 결과가 로컬 상태에 반영되는 순간을 이벤트로 받을 수 있게 됩니다.
또, 다수 체인(majority chain)이 변경되어 처리된 액션이 포함된 블록이 유효하지 않게 될 경우 &lt;a href=&#34;https://docs.libplanet.io/0.3.0/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Unrender_Libplanet_Action_IActionContext_Libplanet_Action_IAccountStateDelta_&#34;&gt;&lt;code&gt;IAction.Unrender()&lt;/code&gt;&lt;/a&gt; 메서드를 통해 이미 렌더링 된 액션을 되돌릴 수 있도록 했습니다.&lt;/p&gt;
&lt;h2 id=&#34;계정-상태-접근-방법-개선&#34;&gt;계정 상태 접근 방법 개선&lt;/h2&gt;
&lt;p&gt;이전 버전에서는 계정의 상태를 가져오기 위해 해당 계정의 상태가 마지막으로 갱신된 블록을 찾을 때까지 이전 블록을 순회하는 방법을 사용했습니다.
이런 방식을 사용하면 해당 주소에 아직 아무런 상태가 기록된 적 없을 경우
최신부터 제너시스까지 모든 블록을 순회해야 하는 문제점이 있습니다.
상태가 마지막으로 업데이트된 지 오래되어 그사이 많은 블록이 추가된 주소의 상태를 구할 때도 마찬가지로 많은 블록을 순회해야 하고,
체인의 길이가 길면 길수록 상태를 확인해야 하는 시간이 늘어나게 됩니다.&lt;/p&gt;
&lt;p&gt;이번 버전에서는 각 계정의 상태를 저장할 때 해당 주소의 상태를 가지고 있는 블록을 인덱싱하고,
상태를 조회할 때는 해당 블록을 바로 조회하는 방식으로 성능을 개선하였습니다.&lt;/p&gt;
&lt;h2 id=&#34;블록-추가-성능-개선&#34;&gt;블록 추가 성능 개선&lt;/h2&gt;
&lt;p&gt;블록체인에 블록을 추가할 때 수행되는 작업의 개선을 통해 블록 추가 성능을 개선했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이미 체인에 추가된 블록에 접근할 때 수행하던 불필요한 블록 검증을 제거했습니다.&lt;/li&gt;
&lt;li&gt;블록이 추가될 때 전체 체인을 검증하던 방식에서 추가되는 블록만 검증하는 방식으로 변경했습니다.&lt;/li&gt;
&lt;li&gt;블록 해시가 필요할 때마다 계산하는 대신 블록 생성 때 한번 계산하도록 변경했습니다.&lt;/li&gt;
&lt;li&gt;블록의 해시를 계산할 때 전체 트랜잭션을 사용하는 대신 트랜잭션 ID를 사용하여 해시 계산 시간을 감소시켰습니다.&lt;/li&gt;
&lt;li&gt;블록을 추가할 때 여러 번 수행되던 액션 평가를 한 번만 수행되도록 하여 블록 추가 시간을 감소시켰습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;그-외&#34;&gt;그 외&lt;/h2&gt;
&lt;p&gt;그 외의 여러 가지 변경 사항은 &lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.3.0&#34;&gt;전체 변경 내역&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;
&lt;p&gt;이번 변경 사항이나 Libplanet에 대해 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href=&#34;https://discord.gg/ue9fgc3&#34;&gt;디스코드 대화방&lt;/a&gt;에 놀러 오세요!&lt;/p&gt;</content><author><name>이승훈</name><uri>https://github.com/earlbread</uri><email>seunghun@planetariumhq.com</email></author></entry><entry><title>Libplanet 팀이 스프린트서울에 참가합니다</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/05/sprintseoul/" title="Libplanet 팀이 스프린트서울에 참가합니다"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/05/sprintseoul/" hreflang="en" title="Libplanet Team will participate in Sprint Seoul"/><id>https://snack.planetarium.dev/kor/2019/05/sprintseoul/</id><published>2019-05-20T00:00:00&#43;00:00</published><updated>2019-05-20T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;오는 6월 29일(토)에 서울 강남에서 모일 &lt;a href=&#34;https://sprintseoul.org/&#34;&gt;스프린트서울&lt;/a&gt;이라는 행사를 아시나요?
오픈 소스에 열정이 있는 분들이 모여서 오픈 소스 프로젝트에 코드나 문서 등을 기여해보는 행사로,
평소에 오픈 소스에 흥미는 있었지만 기여해 볼 계기는 없었던 분들도 이 모임에 오셔서
첫 오픈 소스 기여를 경험할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;스프린트는 오픈 소스 프로젝트의 작성자 또는 기여자와 함께 짧은 시간 동안 함께 문제를 찾고 해결하며,
해당 오픈 소스 프로젝트에 대해 보다 깊게 알아가는 행사입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저희 팀은 이미 지난 4월에도 참가한 바 있으며, 6월 29일에도 참가합니다.
저희 팀은 &lt;a href=&#34;https://libplanet.io/&#34;&gt;Libplanet&lt;/a&gt; 프로젝트 리더로 참가하며,
이 행사를 통해 여러분들의 기여를 기대하고 있습니다.&lt;/p&gt;
&lt;p&gt;스프린트 참가 신청은 6월 20일까지만 받는다고 하며, 신청 양식 및 스프린트서울의 상세한 안내는
&lt;a href=&#34;https://sprintseoul.org/&#34;&gt;공식 홈페이지&lt;/a&gt;에서 살펴보실 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;libplanet-프로젝트-소개&#34;&gt;Libplanet 프로젝트 소개&lt;/h2&gt;
&lt;p&gt;Libplanet이 어떤 프로젝트인지 궁금하실 분들을 위해,
&lt;cite&gt;&lt;a href=&#34;https://snack.planetarium.dev/kor/2019/04/libplanet-0.2/&#34;&gt;Libplanet 0.2 릴리스&lt;/a&gt;&lt;/cite&gt;에서 했던 소개를 인용합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Libplanet은 분산 &lt;abbr title=&#34;Peer-to-Peer&#34;&gt;P2P&lt;/abbr&gt;로 돌아가는 온라인
멀티플레이 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나
데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p&gt;
&lt;p&gt;Libplanet은 널리 쓰이는 Unity 엔진과 함께 쓰일 것을 염두에 두고 만들어져,
현재 C# 언어로 개발되고 있습니다. 물론 Unity 엔진을 쓰지 않더라도 .NET 또는 Mono
플랫폼으로 구현된 게임이라면 쉽게 붙일 수 있도록, &lt;a href=&#34;https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md&#34;&gt;.NET Standard 2.0&lt;/a&gt;을 타깃하여
이식성을 확보하고 있습니다.&lt;/p&gt;
&lt;p&gt;Libplanet의 또 다른 특징은, 프레임워크나 엔진이 아닌 라이브러리라는 점입니다.
엔진이나 프레임워크는 게임 프로세스의 진입점(&lt;code&gt;Main()&lt;/code&gt; 메서드)과 주도권을 가져간 채
허용된 부분에 한해서 게임 프로그래머가 스크립팅할 수 있게 하는 데 반해,
Libplanet은 게임 프로세스를 선점하지 않으며 게임 프로그래머가 명시적으로
호출한 곳에서만 비간섭적으로 (unobtrusively) 동작합니다.
덕분에 Unity 같은 기성 게임 엔진과도 무리 없이 함께 쓸 수 있습니다.&lt;/p&gt;
&lt;p&gt;Libplanet은 &lt;a href=&#34;https://www.nuget.org/packages/Libplanet/&#34;&gt;NuGet&lt;/a&gt;에 올라가 있으며, &lt;a href=&#34;https://docs.libplanet.io/&#34;&gt;API 문서&lt;/a&gt;도 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;개발-환경&#34;&gt;개발 환경&lt;/h2&gt;
&lt;p&gt;먼저, 스프린트에 참여하기 위해서는 개발 환경을 설치해야 합니다. 가급적이면 스프린트
시작 전에 &lt;strong&gt;미리 개발 환경을 설치해 와주시면 감사하겠습니다.&lt;/strong&gt; 어느 프로젝트나 그렇겠지만,
개발 환경 설치에 시간이 생각보다 많이 들기 때문에, 반나절 가까이 허비하는 경우가 흔합니다.&lt;/p&gt;
&lt;p&gt;C#은 Python이나 JavaScript 등과 달리 IDE가 없으면 코딩하기 힘든 언어입니다.
Windows라면 최신 버전의 Visual Studio를 설치하면 되겠지만, 여러 플랫폼에서
두루 쓸 수 있는 IDE로 Rider나 VS Code를 추천합니다. 아래 문서들은
Rider 또는 Visual Studio Code를 쓴다는 가정 하에 Libplanet의 개발 환경을
설치하는 방법을 한국어로 안내하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/dahlia/5333634f62509293cd46c0e4ba65b2f5&#34;&gt;Libplanet 개발 환경 설정 (VS Code)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/dahlia/08f6e659e2266e941ad026f591c30c9a&#34;&gt;Libplanet 개발 환경 설정 (Rider)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 외에, Libplanet 저장소의 &lt;em&gt;&lt;a href=&#34;https://github.com/planetarium/libplanet/blob/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/em&gt; 문서는 CLI 도구만을 이용해서 개발하는 아주
기본적인 개발 환경 설정을 안내합니다. 꼭 자신이 이용하는 에디터를 쓰고 싶은 분들은 이쪽을 읽어주시면
되겠습니다. 단, 그런 경우 Libplanet 커미터들이 당일 행사장에서 도움을 드리기 힘들 수 있기 때문에,
꼭 미리 개발 환경을 잘 설치해서 오시는 게 좋습니다.&lt;/p&gt;
&lt;h2 id=&#34;살펴볼-만한-이슈&#34;&gt;살펴볼 만한 이슈&lt;/h2&gt;
&lt;p&gt;처음 기여하시는 분들을 위한 &lt;a href=&#34;https://github.com/planetarium/libplanet/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22&#34;&gt;초심자용 이슈&lt;/a&gt;들을 모아놨습니다.
프로젝트 구조를 자세히 파악하지 못한 상태에서도 깊게 들어가지 않고 해볼 수 있을 만한 것들입니다.&lt;/p&gt;
&lt;p&gt;어떤 기여를 어떻게 해야 할지 고민이 되는 분들은, 이승훈 님께서 쓰신
&lt;cite&gt;&lt;a href=&#34;https://snack.planetarium.dev/kor/2019/05/first-contribution/&#34;&gt;Libplanet 처음 기여하기&lt;/a&gt;&lt;/cite&gt; 경험담도 도움이 될 것 같습니다.&lt;/p&gt;
&lt;h2 id=&#34;질문-및-대화방&#34;&gt;질문 및 대화방&lt;/h2&gt;
&lt;p&gt;궁금한 게 있으시면 &lt;a href=&#34;https://discord.gg/wUgwkYW&#34;&gt;저희 Discord 서버&lt;/a&gt;에 있는 #libplanet-users-kr 채널에
오셔서 물어보셔도 됩니다. 행사 전에 미리 들어오셔서 물어보셔도 좋고, 행사 끝난 뒤라도
좋습니다.&lt;/p&gt;</content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Unity 2018.2에서 2018.3으로 이주하기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/05/unity-2018.3/" title="Unity 2018.2에서 2018.3으로 이주하기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/05/unity-2018.3/" hreflang="en" title="Migrating from Unity 2018.2 to 2018.3"/><id>https://snack.planetarium.dev/kor/2019/05/unity-2018.3/</id><published>2019-05-17T00:00:00&#43;00:00</published><updated>2019-05-17T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;안녕하세요. 플라네타리움에서 게임을 개발하고 있는 현승민입니다. 게임 개발팀에서는 Unity 2018.3에서 추가되거나 개선된 몇 가지 기능들을 사용하기 위해서 해당 버전으로 이주할 준비를 하고 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;네스티드-프리팹-nested-prefab&#34;&gt;네스티드 프리팹 (Nested Prefab)&lt;/h2&gt;
&lt;p&gt;네스티드 프리팹을 통해 워크플로가 얼마나 개선되는가는 이미 여러곳에서 언급되고 있습니다.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;동시 편집&lt;/dt&gt;
&lt;dd&gt;기존에는 한 프리팹을 고치기 전에 먼저 팀에 얘기를 해 뒀어야 했습니다. 그렇지 않으면 각자의 로컬 저장소에서 저마다 고친 프리팹이 업스트림 저장소에 올릴 때 충돌하기 때문입니다. 하지만 새로운 프리팹은 변경점을 별도의 프리팹으로 구조화해서 이러한 충돌을 방지할 수 있는 방법이 생겼습니다. 여전히 동일한 프리팹 간에는 충돌이 발생할 여지가 있지만, 동일한 프리팹의 범주가 작아져서 그 빈도가 크게 줄었습니다.&lt;/dd&gt;
&lt;dt&gt;다중 구조&lt;/dt&gt;
&lt;dd&gt;기존에는 하나의 프리팹은 그 하위의 모든 객체를 직접 포함하는 단일 구조인 반면, 새로운 프리팹은 하위의 특정 객체를 또 다른 프리팹으로 분리하고, 그렇게 분리한 프리팹 하위의 객체는 해당 프리팹이 관리하도록 다중 구조로 만들 수 있습니다. 이는 프리팹의 모듈화가 가능해지고 재사용성이 좋아져서 중복도 줄어들게 됩니다.&lt;/dd&gt;
&lt;dt&gt;변형&lt;/dt&gt;
&lt;dd&gt;하나의 프리팹을 그대로 상속하지만, 내부 속성을 오버라이드 하거나 컴포넌트 혹은 게임 객체를 추가해서 변형 프리팹을 만들 수 있습니다. 이때 원본 프리팹의 변경이 변형 프리팹에 반영되는 성질이 있어서 프리팹을 관리하는 비용이 줄어듭니다.&lt;/dd&gt;
&lt;dt&gt;프리팹 모드&lt;/dt&gt;
&lt;dd&gt;기존에는 프리팹을 제작하거나 수정하기 위해서 신(scene)에 임시 인스턴스를 만들어서 그것을 수정 후 프리팹에 반영한 뒤 임시 인스턴스를 도로 지워주는 과정이 필요했습니다. 각각의 과정에서 손이 많이 가고 실수 할 여지가 있었는데, 새롭게 추가된 프리팹 모드는 이러한 워크플로를 간단하게 만들어 속도와 안정성에서 개선되었습니다. 아직 프리팹 모드에서 간헐적으로 그래픽 요소들이 보이지 않는 버그가 있는데, 이런 때에는 이전 방식으로 수정해야 하는 상황입니다.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2 id=&#34;메모리-프로파일러&#34;&gt;메모리 프로파일러&lt;/h2&gt;
&lt;p&gt;더욱 강력해진 메모리 프로파일러를 사용해서 문제 해결에 더욱 세세하게 접근할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;2d-애니메이션-v2&#34;&gt;2D 애니메이션 v2&lt;/h2&gt;
&lt;p&gt;기존의 애니메이션 시스템은 워크플로가 너무 불편해서 새로운 애니메이션과 스파인이라는 외부 툴 중 하나로 이주할 필요가 있었습니다. 결과적으로는 스파인을 사용하게 됐지만, 새로운 애니메이션 또한 큰 개선을 확인할 수 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;파티클-시스템&#34;&gt;파티클 시스템&lt;/h2&gt;
&lt;p&gt;이펙트가 중요한 프로젝트를 진행 중이기 때문에 개선된 파티클 시스템을 통해 전반적인 이펙트 개선을 의도했습니다. 리소스에 아무런 수정도 하지 않았지만, 이펙트가 시각적으로 나아졌다는 아트팀의 피드백이 있을 정도로 확실한 개선점을 확인할 수 있었습니다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;하지만, 이주를 진행하기 하루 전 Unity 2019.1이 정식 출시되는 당황스러운 상황이 발생합니다. 다음 글에서는 Unity 2019.1에서 추가된 기능을 살펴보고 저희가 어떻게 대응했는지를 이야기 하겠습니다.&lt;/p&gt;</content><author><name>현승민</name><uri>https://github.com/boscohyun</uri><email>seungmin@planetariumhq.com</email></author></entry><entry><title>Libplanet 처음 기여하기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/05/first-contribution/" title="Libplanet 처음 기여하기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/05/first-contribution/" hreflang="en" title="First Contribution to Libplanet"/><id>https://snack.planetarium.dev/kor/2019/05/first-contribution/</id><published>2019-05-07T00:00:00&#43;00:00</published><updated>2019-05-07T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;안녕하세요. 플라네타리움 개발팀 이승훈입니다. 플라네타리움에서 일하는 것이 매력적인 이유 중 하나는 오픈 소스 개발자로 일할 수 있다는 게 아닐까 합니다. 이번 글은 제가 &lt;a href=&#34;https://github.com/planetarium/libplanet&#34;&gt;Libplanet&lt;/a&gt; 프로젝트에 했던 첫 기여에 대한 이야기입니다. Libplanet에 대한 소개는 &lt;cite&gt;&lt;a href=&#34;https://snack.planetarium.dev/kor/2019/04/libplanet-0.2/&#34;&gt;Libplanet 0.2 릴리스&lt;/a&gt;&lt;/cite&gt;를 참고해주세요.&lt;/p&gt;
&lt;h2 id=&#34;왜-libplanet에-기여했을까&#34;&gt;왜 Libplanet에 기여했을까?&lt;/h2&gt;
&lt;p&gt;지난 1월 플라네타리움은 첫 채용 공고를 오픈함과 동시에 Libplanet 프로젝트의 저장소를 공개했습니다. 매력적인 팀과 프로젝트라고 생각했지만 Libplanet은 유니티와 연동하기 위해 C#으로 개발되고 있었고 저는 주로 파이썬으로 개발해왔기 때문에 선뜻 지원하기가 망설여졌습니다. 그래서 Libplanet이 오픈 소스로 열려있기도 하니 간단한 것이라도 개발에 한 번 참여해보고 결정하기로 마음을 먹었습니다.&lt;/p&gt;
&lt;h2 id=&#34;c-개발-환경&#34;&gt;C# 개발 환경&lt;/h2&gt;
&lt;p&gt;저의 경우 이전에는 맥에서 파이썬 위주로 개발을 했습니다. 종종 관심 있는 파이썬 오픈 소스 프로젝트에 기여하곤 했었는데, 파이썬 개발자들이 맥을 많이 사용하기도 하고 오픈 소스에도 친숙한 편이어서 크게 어려움을 느끼지 않고 참여할 수 있었습니다. 그런데 막상 맥에서 C# 개발 환경을 구축하려고 하니 무엇을 설치해야 할지부터 막막했습니다. 다행히 예전과는 다르게 &lt;a href=&#34;https://www.mono-project.com/&#34;&gt;Mono&lt;/a&gt;나 &lt;a href=&#34;https://en.wikipedia.org/wiki/.NET_Core&#34;&gt;.NET Core&lt;/a&gt;와 같은 프로젝트들이 있어서 맥에서도 .NET 개발을 할 수 있고, &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VS Code&lt;/a&gt; 등의 에디터들에서도 C# 개발을 하기 위한 플러그인들을 잘 지원하는 편이라 큰 어려움 없이 개발 환경을 설치할 수 있었습니다. 현재는 Libplanet에서도 프로젝트에 기여하려는 개발자들을 위한 &lt;a href=&#34;https://gist.github.com/dahlia/5333634f62509293cd46c0e4ba65b2f5&#34;&gt;개발 환경 설정 방법&lt;/a&gt;을 제공하기 때문에 좀 더 수월하게 환경을 설정할 수 있을 것 같습니다.&lt;/p&gt;
&lt;h2 id=&#34;어떤-걸-기여할까&#34;&gt;어떤 걸 기여할까?&lt;/h2&gt;
&lt;p&gt;Libplanet 주소는 &lt;a href=&#34;https://www.ethereum.org/&#34;&gt;이더리움&lt;/a&gt;의 주소형식을 차용하고 있습니다. 이더리움 주소는 &lt;a href=&#34;https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md&#34;&gt;EIP-55&lt;/a&gt;에서 제안된 대소문자를 혼합한 형식의 체크섬을 사용하고 있는데, 이 주소 형식의 예제는 아래와 같습니다.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;십육진법&lt;/dt&gt;
&lt;dd&gt;&lt;code&gt;0xd1220a0cf47c7b9be7a2e6ba89f429762e7b9adb&lt;/code&gt;&lt;/dd&gt;
&lt;dt&gt;EIP-55 체크섬&lt;/dt&gt;
&lt;dd&gt;&lt;code&gt;0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb&lt;/code&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;당시에 Libplanet 주소의 문자열 표현은 소문자만으로 구성된 십육진법이었습니다. 따라서 주소의 문자열 표현을 이더리움에서 사용하고 있는 EIP-55 체크섬 형식으로 표현되도록 구현해야 하는 이슈였습니다. 자세한 내용은 해당 &lt;a href=&#34;https://github.com/planetarium/libplanet/issues/33&#34;&gt;이슈&lt;/a&gt;와 &lt;a href=&#34;https://github.com/planetarium/libplanet/pull/43&#34;&gt;PR&lt;/a&gt;을 참고하실 수 있습니다.&lt;/p&gt;
&lt;p&gt;C#에서의 개발 경험이 거의 없었고 프로젝트 배경지식도 별로 없는 상황이었지만 많은 모듈을 고치지 않아도 되는 간단한 이슈여서 큰 어려움 없이 첫 기여를 진행할 수 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;기여를-통해-알게된-것&#34;&gt;기여를 통해 알게된 것&lt;/h2&gt;
&lt;p&gt;첫 기여를 통해서 알게 된 점은 맥에서의 C# 개발 환경이 생각했던 것보다는 해볼 만하다는 것입니다. C#이 대중화된 멀티 패러다임 프로그래밍 언어를 지향하기 때문에 언어 자체의 어려움은 별로 없었습니다. 맥에서의 .NET 개발 환경도 개발하는 데 큰 무리는 없었지만, 써드파티 라이브러리나 윈도우외의 플랫폼에서 다양한 도구 지원은 아직 미비한 부분이 있었습니다. 하지만 최근 마이크로소프트의 오픈 소스 정책과 멀티 플랫폼 정책에 힘입어 차츰 나아질 것으로 보입니다.&lt;/p&gt;
&lt;p&gt;또한 플라네타리움 팀의 개발문화도 경험할 수 있었는데, 깃허브에서 모든 이슈가 기록되고 전 세계 오픈 소스 커뮤니티와 소통하기 위해 영어를 사용한다는 점이 인상적이었습니다. 그리고 외부에서 기여를 받고 있기 때문에 코드 리뷰가 필수적으로 진행되고 CI를 통해 테스트뿐 아니라 체인지로그 같은 사항들도 자동화되어 관리되고 있다는 점이 좋았습니다.&lt;/p&gt;
&lt;h2 id=&#34;마치며&#34;&gt;마치며&lt;/h2&gt;
&lt;p&gt;저는 첫 기여 후에 플라네타리움팀에 합류한 지 약 한 달 정도 되었고 함께 즐겁게 일하고 있습니다. 플라네타리움에서 함께 Libplanet을 만들 &lt;a href=&#34;https://www.notion.so/8996647777d24491a5dc92d82ba37ec2&#34;&gt;소프트웨어 엔지니어&lt;/a&gt;를 찾고 있으니 관심있는 분들은 &lt;a href=&#34;https://www.notion.so/98129a2f333d4d17b25ce268d72d326c&#34;&gt;채용 정보&lt;/a&gt; 페이지를 확인해주세요.&lt;/p&gt;
&lt;p&gt;플라네타리움은 Libplanet 기여를 활성화하기 위해 &lt;a href=&#34;https://comuka.nonce.community/&#34;&gt;코드먹는하마&lt;/a&gt;, &lt;a href=&#34;https://sprintseoul.org/&#34;&gt;스프린트서울&lt;/a&gt; 등의 행사에 참여했고 앞으로도 활발하게 참여할 예정입니다. 또한 처음 기여하시는 분들을 위한 &lt;a href=&#34;https://github.com/planetarium/libplanet/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22&#34;&gt;초심자용 이슈&lt;/a&gt;들이 있으니 관심 있는 분들은 참고하시면 좋을 것 같습니다.&lt;/p&gt;
&lt;p&gt;프로젝트에 궁금한 점이 있으신 분들은 언제든 저희 팀이 상주해 있는 &lt;a href=&#34;https://discord.gg/ue9fgc3&#34;&gt;디스코드 대화방&lt;/a&gt;에 놀러 오시길 바랍니다!&lt;/p&gt;</content><author><name>이승훈</name><uri>https://github.com/earlbread</uri><email>seunghun@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.2 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/04/libplanet-0.2/" title="Libplanet 0.2 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/04/libplanet-0.2/" hreflang="en" title="Libplanet 0.2 Released"/><id>https://snack.planetarium.dev/kor/2019/04/libplanet-0.2/</id><published>2019-04-09T00:00:00&#43;00:00</published><updated>2019-04-09T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;안녕하세요. 지난주 저희 팀은 &lt;a href=&#34;https://libplanet.io/&#34;&gt;Libplanet&lt;/a&gt;의 두번째 마이너 버전&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;인 &lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.2.0&#34;&gt;0.2 버전&lt;/a&gt;을 릴리스했습니다.
여러 변화가 있었지만, 이 글에서는 몇 가지 주요 기능 추가 및 API 변경에 대해 다루겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;libplanet-소개&#34;&gt;Libplanet 소개&lt;/h2&gt;
&lt;p&gt;이에 앞서, 이 블로그에 &lt;a href=&#34;https://libplanet.io/&#34;&gt;Libplanet&lt;/a&gt;을 소개한 적이 없으니 간략히 설명을 하고 넘어가겠습니다.&lt;/p&gt;
&lt;p&gt;Libplanet은 분산 &lt;abbr title=&#34;Peer-to-Peer&#34;&gt;P2P&lt;/abbr&gt;로 돌아가는 온라인
멀티플레이 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나
데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p&gt;
&lt;p&gt;Libplanet은 널리 쓰이는 Unity 엔진과 함께 쓰일 것을 염두에 두고 만들어져,
현재 C# 언어로 개발되고 있습니다. 물론 Unity 엔진을 쓰지 않더라도 .NET 또는 Mono
플랫폼으로 구현된 게임이라면 쉽게 붙일 수 있도록, &lt;a href=&#34;https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md&#34;&gt;.NET Standard 2.0&lt;/a&gt;을 타깃하여
이식성을 확보하고 있습니다.&lt;/p&gt;
&lt;p&gt;Libplanet의 또 다른 특징은, 프레임워크나 엔진이 아닌 라이브러리라는 점입니다.
엔진이나 프레임워크는 게임 프로세스의 진입점(&lt;code&gt;Main()&lt;/code&gt; 메서드)과 주도권을 가져간 채
허용된 부분에 한해서 게임 프로그래머가 스크립팅할 수 있게 하는 데 반해,
Libplanet은 게임 프로세스를 선점하지 않으며 게임 프로그래머가 명시적으로
호출한 곳에서만 비간섭적으로 (unobtrusively) 동작합니다.
덕분에 Unity 같은 기성 게임 엔진과도 무리 없이 함께 쓸 수 있습니다.&lt;/p&gt;
&lt;p&gt;Libplanet은 &lt;a href=&#34;https://www.nuget.org/packages/Libplanet/&#34;&gt;NuGet&lt;/a&gt;에 올라가 있으며, &lt;a href=&#34;https://docs.libplanet.io/&#34;&gt;API 문서&lt;/a&gt;도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;abbr-title-network-address-translation-nat-abbr-우회&#34;&gt;&lt;abbr title=&#34;Network Address Translation&#34;&gt;NAT&lt;/abbr&gt; 우회&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.1.0&#34;&gt;첫 버전&lt;/a&gt;부터도 P2P 통신은 됐지만, 피어는 모두 공인 IP를 갖고 있어야 했습니다.
즉, 공유기 뒤에 있는 피어와는 통신이 되지 않았기 때문에, 현실적으로는 쓰임이 제한적이었습니다.
이를 해결하는 것이 급선무였기 때문에 어떻게든 NAT를 우회하는 것이 0.2 로드맵에서 가장 중요했고,
우선은 조금 비효율적이어도 가장 많은 케이스를 커버하고자
&lt;abbr title=&#34;Traversal Using Relays around NAT&#34;&gt;TURN&lt;/abbr&gt; 및
&lt;abbr title=&#34;Session Traversal Utilities for NAT&#34;&gt;STUN&lt;/abbr&gt;이라 불리는
&lt;a href=&#34;https://tools.ietf.org/html/rfc5766&#34;&gt;RFC 5766&lt;/a&gt; 및 &lt;a href=&#34;https://tools.ietf.org/html/rfc5389&#34;&gt;RFC 5389&lt;/a&gt;를 구현했습니다. 이 과정에서 오픈 소스 C# 구현을 찾지 못해
스펙에서 필요한 부분들을 모두 직접 구현하는 수고를 같은 팀의 문성원 님이 해주셨습니다.
이 경험을 풀어서 쓴 &lt;cite&gt;&lt;a href=&#34;https://snack.planetarium.dev/kor/2019/04/nat_traversal_1/&#34;&gt;NAT를 넘어서 가자&lt;/a&gt;&lt;/cite&gt;라는 글도 읽어주시기 바랍니다!&lt;/p&gt;
&lt;h2 id=&#34;좀-더-게임스러운-트랜잭션&#34;&gt;좀 더 게임스러운 트랜잭션&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Tx.Transaction-1.html&#34;&gt;&lt;code&gt;Transaction&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;은 네트워크 구성원 사이에 데이터를 동기화하는 단위입니다.
Libplanet은 이전 버전까지는 비슷한 문제를 푸는 &lt;a href=&#34;https://bitcoin.org/&#34;&gt;비트코인&lt;/a&gt; 같은 기존 기술을 참고했기 때문에,
모든 트랜잭션에 발신자와 수신자가 있다는 개념을 그대로 받아들였습니다.
비트코인은 송금을 다루므로 재화가 이동하기만 하며 복제되어선 안 됩니다.
따라서 보내는 사람이 있다면 받는 사람이 꼭 있어야 하며,
모든 트랜잭션에 발신자와 수신자가 있다는 개념이 자연스럽습니다.
하지만 게임에서는 캐릭터의 이동처럼 수신자 개념이 없는 행동이나,
광역기처럼 수신자가 둘 이상일 수 있는 행동도 자주 나타납니다.&lt;/p&gt;
&lt;p&gt;이러한 상황을 더 자연스럽게 다룰 수 있도록,
이번 버전부터는 &lt;code&gt;Transaction&amp;lt;T&amp;gt;&lt;/code&gt;의 &lt;code&gt;Sender&lt;/code&gt;–&lt;code&gt;Recipient&lt;/code&gt; 개념이 사라지고,
대신 &lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Tx.Transaction-1.html#Libplanet_Tx_Transaction_1_Signer&#34;&gt;&lt;code&gt;Signer&lt;/code&gt;&lt;/a&gt;–&lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Tx.Transaction-1.html#Libplanet_Tx_Transaction_1_UpdatedAddresses&#34;&gt;&lt;code&gt;UpdatedAddresses&lt;/code&gt;&lt;/a&gt; 개념이 그 자리를 갈음하게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;새로운-상태-접근-api&#34;&gt;새로운 상태 접근 API&lt;/h2&gt;
&lt;p&gt;기존에는 모든 &lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Action.IAction.html&#34;&gt;&lt;code&gt;IAction&lt;/code&gt;&lt;/a&gt; 구현은 &lt;code&gt;Execute()&lt;/code&gt; 메서드 안에서 접근할 계정의 주소 목록을
반드시 &lt;code&gt;RequestStates()&lt;/code&gt; 메서드를 통해 제출해야 했습니다.
&lt;code&gt;Execute()&lt;/code&gt; 메서드에서 미리 제출하지 않은 주소의 상태를 읽거나 쓰려고 하면 유효하지 않은
액션으로 취급됐습니다.&lt;/p&gt;
&lt;p&gt;하지만 블록체인을 통해 공개 네트워크에서 공유된 상태들은 어차피 누구나 읽을 수 있기 때문에,
읽기의 제한은 큰 의미가 없으며 쓰기의 제한만 있으면 된다는 결론에 이르게 됐습니다.&lt;/p&gt;
&lt;p&gt;또한, 기존에는 접근할 계정에 대한 정보가 &lt;code&gt;RequestStates()&lt;/code&gt; 메서드와 &lt;code&gt;Execute()&lt;/code&gt; 메서드
양쪽 코드에 중복되므로 버그가 나기 쉬운 구조였고, 조심한다고 하더라도 양쪽을 함께 고쳐야 하는
API도 매우 불편했습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제들을 두루 풀고자, 이번 버전부터는 &lt;code&gt;IAction&lt;/code&gt; 인터페이스의 상태 접근 API가
크게 개선됐습니다. &lt;code&gt;RequestStates()&lt;/code&gt; 메서드는 아예 사라졌으며,
&lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Execute_Libplanet_Action_IActionContext_&#34;&gt;&lt;code&gt;IAction.Execute()&lt;/code&gt;&lt;/a&gt;의 인자로 들어온 &lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Action.IActionContext.html&#34;&gt;&lt;code&gt;IActionContext&lt;/code&gt;&lt;/a&gt; 객체의
&lt;a href=&#34;https://docs.libplanet.io/0.2.1/api/Libplanet.Action.IActionContext.html#Libplanet_Action_IActionContext_PreviousStates&#34;&gt;&lt;code&gt;PreviousStates&lt;/code&gt;&lt;/a&gt;가 일종의 &amp;ldquo;변경 기록&amp;rdquo; API를 제공하게 되었습니다.
이 변경 기록을 &lt;code&gt;Execute()&lt;/code&gt; 메서드 안에서 쌓아 나간 뒤,
최종적으로 그 변경 기록을 반환하면 상태가 실제로 갱신됩니다.&lt;/p&gt;
&lt;p&gt;또한, 트랜잭션이 만들어질 때 액션이 &amp;ldquo;리허설 모드&amp;rdquo;로 실행되는데,
이 리허설을 통해 &lt;code&gt;Execute()&lt;/code&gt; 메서드가 상태를 갱신하려고 하는 주소의 목록을 얻어서
이 목록도 함께 트랜잭션에 포함되어 서명됩니다.
서명된 트랜잭션을 다른 노드가 받았을 때는, 트랜잭션을 서명한 당사자가 리허설을 통해
구한 주소 목록 이외의 계정 상태를 바꾸는 것이 차단됩니다.&lt;/p&gt;
&lt;h2 id=&#34;액션의-서브타입-다형성-분리&#34;&gt;액션의 서브타입 다형성 분리&lt;/h2&gt;
&lt;p&gt;이전 버전까지는 게임마다 &lt;code&gt;IAction&lt;/code&gt;을 구현한 추상 클래스를 정의하고,
이를 상속하는 여러 구체 클래스를 두는 것이 Libplanet이 상정한 유일한 이용법이었습니다.
그러나 게임에 따라 게임 내 액션의 종류를 &lt;code&gt;IAction&lt;/code&gt; 수준에서 나누는 것보다,
&lt;code&gt;IAction&lt;/code&gt;을 단 하나의 클래스로 구현하고 액션에 들어가는 데이터를 통해 동작을 세분화하는 방식이
더 적합한 경우도 있습니다. 또, 액션의 타입에 따라 동적으로 디스패치하는 방식은 내부적으로
&lt;a href=&#34;https://docs.microsoft.com/ko-kr/dotnet/framework/reflection-and-codedom/reflection&#34;&gt;.NET의 리플렉션&lt;/a&gt;을 써서 구현했기 때문에 이러한 것이 곤란한 프로젝트도 있을 수 있습니다.&lt;/p&gt;
&lt;p&gt;그래서 이번 버전부터는 &lt;code&gt;Transaction&amp;lt;T&amp;gt;&lt;/code&gt;의 &lt;code&gt;T&lt;/code&gt;는 &lt;code&gt;IAction&lt;/code&gt;을 구현할 뿐만 아니라 구체 클래스만을
받아들이게 됐습니다. 추상 클래스나 인터페이스는 &lt;code&gt;IAction&lt;/code&gt;을 구현했다고 해도 받아들여지지 않으며,
구체 클래스 역시 서브타입의 존재는 완전히 무시되게 됩니다.&lt;/p&gt;
&lt;p&gt;대신, 기존처럼 서브타입 다형성을 통해 액션의 동작을 세분화하고 싶다면,
&lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.2.1&#34;&gt;&lt;code&gt;PolymorphicAction&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;라는 새로운 액션 데코레이터 구현을 쓰면 됩니다.
예를 들어 기존의 타입이 &lt;code&gt;Transaction&amp;lt;AbstractAction&amp;gt;&lt;/code&gt;이었다면,
&lt;code&gt;Transaction&amp;lt;PolymorphicAction&amp;lt;AbstractAction&amp;gt;&amp;gt;&lt;/code&gt; 타입으로 고쳐서 쓰면
대부분의 경우 기존대로 동작하게 됩니다.
물론, &lt;code&gt;PolymorphicAction&amp;lt;T&amp;gt;&lt;/code&gt; 클래스는 내부적으로 .NET 리플렉션을 씁니다.&lt;/p&gt;
&lt;h2 id=&#34;그-외&#34;&gt;그 외&lt;/h2&gt;
&lt;p&gt;그밖에도 여러 변화가 있었고, 자세한 것은 &lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.2.0&#34;&gt;전체 변경 내역&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;참고로 &lt;em&gt;0.2.0&lt;/em&gt; 버전이 릴리스된 뒤 이틀 뒤에 몇 가지 문제를 해결한 &lt;a href=&#34;https://github.com/planetarium/libplanet/releases/tag/0.2.1&#34;&gt;&lt;em&gt;0.2.1&lt;/em&gt;&lt;/a&gt;이 릴리스되어,
(2019년 4월 9일) 현재 최신 버전은 &lt;em&gt;0.2.1&lt;/em&gt;입니다.&lt;/p&gt;
&lt;p&gt;호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이 상주해 있는
&lt;a href=&#34;https://discord.gg/ue9fgc3&#34;&gt;디스코드 대화방&lt;/a&gt;에 놀러오세요!&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;저희는 아직 메이저 릴리스를 한 적이 없습니다.
&lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>NAT를 넘어서 가자</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/04/nat_traversal_1/" title="NAT를 넘어서 가자"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/04/nat_traversal_1/" hreflang="en" title="Moving Beyond NAT"/><id>https://snack.planetarium.dev/kor/2019/04/nat_traversal_1/</id><published>2019-04-04T00:00:00&#43;00:00</published><updated>2019-04-04T00:00:00&#43;00:00</updated><content type="html">
&lt;p&gt;안녕하세요. 플라네타리움 개발팀 문성원입니다. 오늘은 &lt;a href=&#34;https://en.wikipedia.org/wiki/NAT_traversal&#34;&gt;NAT 통과 기법&lt;/a&gt;이라고 알려진 방법에 대해서 이야기를 해볼까 합니다.&lt;/p&gt;
&lt;h2 id=&#34;뭐가-문젠가요&#34;&gt;뭐가 문젠가요?&lt;/h2&gt;
&lt;p&gt;게임 서버에서 스마트폰에 이르기까지 현대 인터넷에 참여하는 모든 단말은 &lt;a href=&#34;https://en.wikipedia.org/wiki/IP_address&#34;&gt;IP 주소&lt;/a&gt;를 가지고 있습니다. 이는 한 단말이 다른 단말에 연결하여 메시지를 주고받기 위함인데요.&lt;/p&gt;
&lt;p&gt;근본적인 문제는 이러한 IP 주소의 수량이 한정되어 있다는 것입니다. 널리 쓰이는 &lt;a href=&#34;https://en.wikipedia.org/wiki/IPv4&#34;&gt;IPv4&lt;/a&gt;의 경우엔 32비트로 구성되어 단순 계산으론 2&lt;sup&gt;32&lt;/sup&gt;개(약 40억개 이상)를 할당할 수 있습니다. (물론 이걸 전부 사용하는 것은 아닙니다.) 얼핏 보면 충분해 보이기도 하지만, 1인당 1개 이상의 기기를 운용하기에는 턱없이 모자라지요. 실제로 2011년 이후로 &lt;a href=&#34;https://en.wikipedia.org/wiki/IPv4_address_exhaustion&#34;&gt;IPv4 주소가 모두 소진&lt;/a&gt;되어 신규 주소도 할당이 되지 않는 상태입니다.&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해, 주소 공간을 128비트로 크게 늘린 &lt;a href=&#34;https://en.wikipedia.org/wiki/IPv6&#34;&gt;IPv6&lt;/a&gt;가 제안되었으나, IPv4 주소 고갈에 비해 보급이 더뎠습니다. 해서 많은 네트워크 담당자들은 네트워크를 분리하여 복수의 사설 IP를 두고, 인터넷엔 그러한 주소를 변환하여 하나의 공인 IP로만 접속하게 하는 방식을 택했습니다. 흔히 이야기하는 &lt;a href=&#34;https://en.wikipedia.org/wiki/Network_address_translation&#34;&gt;NAT(Network Address Translation)&lt;/a&gt;는 이러한 작업을 이르는 말인 동시에, 경우에 따라선 해당 작업을 처리하는 장치(일반적으론 &lt;a href=&#34;https://en.wikipedia.org/wiki/Router_(computing)&#34;&gt;라우터&lt;/a&gt;)를 일컫기도 합니다.&lt;/p&gt;
&lt;p&gt;서버–클라이언트 모델에서 이런 NAT를 통한 인터넷 접속은 크게 문제가 되지 않습니다. 서버가 공인 IP를 가지고 있다면, 클라이언트는 NAT를 거치건 거치지 않건 접속할 수 있기 때문이죠. 하지만 만약 NAT 안쪽에 있는 단말에 접속해야 한다면 문제가 발생합니다. NAT 안쪽의 사설 네트워크의 IP로는 NAT 바깥의 단말들이 접속할 수 없기 때문이죠. 이러한 상황을 해결하기 위한 기법들을 NAT 통과 기법이라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;그래서-뭘-써야-하나요&#34;&gt;그래서 뭘 써야 하나요?&lt;/h2&gt;
&lt;h3 id=&#34;upnp-igdp&#34;&gt;UPnP (IGDP)&lt;/h3&gt;
&lt;p&gt;NAT를 통과하는 기법은 크게 NAT의 도움을 받느냐 그렇지 않느냐로 구분할 수 있습니다. 장비들의 연결성이 중시되는 현대 인터넷의 요구 사항에 맞춰서 제안된 &lt;a href=&#34;https://en.wikipedia.org/wiki/Universal_Plug_and_Play&#34;&gt;UPnP&lt;/a&gt;와 같은 프로토콜은, NAT 통과 문제를 해결하는 기능(예: &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Gateway_Device_Protocol&#34;&gt;Internet Gateway Device Protocol&lt;/a&gt;)을 지원하기도 합니다. 다만, 이는 어디까지나 해당 프로토콜을 지원하는 장비에만 적용할 수 있는 해결책입니다. 어떠한 장비들은 UPnP를 선택적으로 지원하거나, 아예 지원하지 않을 수도 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;relay-turn&#34;&gt;Relay (TURN)&lt;/h3&gt;
&lt;p&gt;다른 한 가지 방법은 NAT의 도움을 받지 않는 방법입니다. 다시 이야기하면, 사설 IP ↔ 공인 IP 체계를 유지한 상태에서 외부에서 접속이 가능하게 한다는 것이기도 합니다. 어떻게 할 수 있을까요? 이쯤에서 우리가 할 수 있는 것과 할 수 없는 일을 정리하면 아래와 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공인 IP를 가진 단말은
&lt;ul&gt;
&lt;li&gt;다른 단말의 연결을 처리할 수 있습니다.&lt;/li&gt;
&lt;li&gt;다른 공인 IP를 가진 단말에 연결할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;사설 IP를 가진 단말은
&lt;ul&gt;
&lt;li&gt;다른 단말의 연결을 처리할 수 없습니다.
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;아주 엄밀하게 말하면, 같은 네트워크 안에선 가능합니다. 하지만 이야기를 단순하게 하기 위해 이 경우는 제외하겠습니다. :)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;다른 공인 IP를 가진 단말에 연결할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉 별도의 공인 IP를 가진 서버(S)를 가정하고, 이 서버가 (본래라면 NAT 뒤의 단말이 처리해야 할) 연결을 대신 처리하면서 내용을 NAT 뒤의 단말에 전달(릴레이)해주면 NAT의 동작에 의존하지 않고 확실하게 연결을 처리할 수 있습니다. 이를 릴레이 기법이라고 하며, &lt;a href=&#34;https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT&#34;&gt;TURN&lt;/a&gt;이라는 표준으로 정의되어 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;홀-펀칭&#34;&gt;홀 펀칭&lt;/h3&gt;
&lt;p&gt;NAT의 직접적인 도움을 받지 않는 다른 방법 중 한 가지는 &lt;a href=&#34;https://en.wikipedia.org/wiki/Hole_punching_(networking)&#34;&gt;홀 펀칭(Hole Punching)&lt;/a&gt;이라 불리는 기법입니다. (흔히 &lt;a href=&#34;https://en.wikipedia.org/wiki/UDP_hole_punching&#34;&gt;UDP 홀펀칭&lt;/a&gt;으로 널리 알려졌지만, &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_hole_punching&#34;&gt;TCP에 대해서도 적용할 수 있습니다.&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;홀 펀칭 역시 위의 릴레이와 마찬가지로 중계 서버(S)를 가정합니다. 다만 릴레이와 다른 점은, 중계 서버가 직접 통신을 전부 중계하는 것이 아니라, 접속을 처리할 단말(A)이 속한 NAT의 공인 IP와 포트 정보만 접속을 원하는 단말(B)에 넘겨서, B가 A에 접속할 때 A의 사설 IP가 아닌 NAT의 공인 IP와 포트로 접속을 시도하는 방식입니다.&lt;/p&gt;
&lt;p&gt;홀 펀칭은 UPnP처럼 NAT에 특정 프로토콜의 구현을 요구하는 것은 아니지만, NAT의 포트 매핑 방식을 이용하는 기법이기 때문에, 동작 모드에 따라, 보다 정확하게 이야기하자면, 목적지 독립적 매핑(Endpoint Independent Mapping)으로 동작하는 NAT에서만 적용 가능합니다.&lt;/p&gt;
&lt;h2 id=&#34;다음-이야기들&#34;&gt;다음 이야기들&lt;/h2&gt;
&lt;p&gt;위에서 살펴 본 NAT 통과 기법들은 실현 가능한 상황이나 장단점이 각기 다릅니다. 해서 현업에서는 다양한 방법을 복합적으로 사용합니다. 다음 시간에는 그 중에서 가장 비싸지만 가장 안정적으로 통신을 보장할 수 있는 TURN을 이용한 릴레이 기법에 대해서 더 자세히 살펴보도록 하겠습니다.&lt;/p&gt;</content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>시작하며</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/03/beginning/" title="시작하며"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/03/beginning/" hreflang="en" title="Prologue"/><id>https://snack.planetarium.dev/kor/2019/03/beginning/</id><published>2019-03-29T00:00:00&#43;00:00</published><updated>2019-03-29T00:00:00&#43;00:00</updated><content type="html">&lt;p&gt;안녕하세요.
블록체인 기술을 통해 탈중앙 멀티플레이 게임과 함께,
&lt;a href=&#34;https://libplanet.io/&#34;&gt;누구나 그런 게임을 만들 수 있는 오픈 소스 라이브러리&lt;/a&gt;를
만들고 있는 &lt;a href=&#34;https://planetariumhq.com/&#34;&gt;플라네타리움&lt;/a&gt; 팀입니다.&lt;/p&gt;
&lt;p&gt;탈중앙화나 블록체인에 대해서는 2009년에 &lt;a href=&#34;https://bitcoin.org/&#34;&gt;비트코인&lt;/a&gt;이 선을 보인 이래로
많은 연구나 개발이 진행이 된 분야입니다. 더 거슬러 올라가자면 컴퓨터 과학
분야에서 &lt;a href=&#34;https://en.wikipedia.org/wiki/Distributed_computing&#34;&gt;분산 컴퓨팅&lt;/a&gt;이란 이름으로 연구되던 부분이기도 하죠.
하지만 이러한 기술을 블록체인 코어 레벨에서 게임 개발 프로세스와 연결해서
개발하다 보니 기존 연구를 바로 적용하기 어렵거나, 게임 개발에 필요한
플랫폼에 구현체가 없는 경우가 종종 있었습니다.&lt;/p&gt;
&lt;p&gt;저희는 스낵처럼 짧은 글들을 통해, 이런 시행착오를 통해 어떤 것을
배웠는지를 공유하려고 합니다.
&amp;ldquo;스낵&amp;rdquo;이란 이름에서 드러나는 것처럼, 일반적인 블로그 포스팅에 비해
읽는 쪽도 쓰는 쪽도 크게 부담이 가지 않는 짧은 호흡을 지향하고 있으며
그만큼 갱신도 자주 하려고 합니다.&lt;/p&gt;
&lt;p&gt;그럼 첫 포스팅으로 찾아뵙겠습니다.&lt;/p&gt;</content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry></feed>